#!/usr/bin/env python3

import sys, os
from math import ceil
from time import time
from getpass import getuser
from subprocess import check_output as co
from subprocess import call
from serverTools import submit, syncDir, runJob

workdir = os.getcwd()
user = getuser()

def usage():
	print("""
Usage:

	genconf			Runs the script (if no flags are input, the
				default values will be used)

Default Values:

	Input File 		If no input file is specified, conformers will
				be generated for ALL .mol2 files in the directory
				at the time the script was run. Omitting this value
				will cause the script to ignore the value for
				Output File and revert to the default. RUNNING MULTIPLE
				MOL2 FILES IS NOT RECOMMENDED AS IT CAN CREATE A 
				LARGE NUMBER OF FILES AND POTENTIALLY INTERFERE WITH
				THE SCRIPT'S PERFORMANCE.
	Output File 		The initial output file will be named 
				<input_filename>_conformers.mol2.
				Regardless, all additional files will be saved as 
				<input_filename>_conf_<confomer_number>.mol2
	Nconf 			5000
	Top 			50
	Charge 			0
	Qm Theory 		AM1
	Score 			RMSD
	Method 			Gamess

Optional Flags:

	-h,  --help 		Shows this message
	--remove_conf 		Deletes all files generated by this script
	-io, --inp_only 	Does not run sqm. Will only generate input files
	-R,  --Run 		Requests the jobs be automatically submitted by this
				script. This command overwrites the input only flag and
				writes a batchfile to submit all jobs for energy calculations.
				NOTE: As of 11/21/2019, the functionality of this flag has 
				changed!!! -- instead of submitting the jobs, it creates a 
				job submit script. 
	-i,  --input 		Declares input file (Must be mol2 format)
	-o,  --output 		Declares output filename.
	-n,  --nconf 		Declares the maximum number of conformers requested.
						You will likely get a lot less conformers.
	-t,  --top 		Declares the number of low energy conformors to save
	-c,  --charge 		Declares the molecule's net charge.
	-qm, --qm_theory 	Declares QMMM or QM calculation method. Options:
					SQM:
						AM1, RM1, MNDO, PM3-PDDG, MNDO-PDDG, PM3-CARB1
						MNDO/d, AM1/d, PM6, DFTB2, DFTB3, AM1-D*, PM6-D
						AM1-DH+, PM6-DH+
					GAMESS:
						MINI
					Gaussian:
						Not Currently Supported
	-s,  --score 		Declares scoring method. Options: 
					rmsd, energy, minrmsd, minenergy
	-m,  --method 	Energy calculation method. Options: 
						SQM, GAMESS, Gaussian (Not currently Supported)
""")
	#############################################################################
	#						   OLD OR UNUSED OPTIONS 				 			#
	#############################################################################
	#	Sqm 			If sqm is in your path, this is not needed. If it is 
	#					NOT in your path, the -sq or --sqm flag MUST be used.
	#   -sq, --sqm 		Declares the full path to the sqm executable
	#############################################################################


def removeConformers():
	for i in os.listdir():
		if  '_conf' in i or '_logfile' in i or 'sqm' in i or 'analysis.in' in i or '.sh' in i:
			os.remove(i)
	print('Removed all files generated by this script.')

def writeAnalysisInput(METHOD, charge, joblist_file, conformers, top):
	with open('analysis.in','w') as f:
		f.write("{}\n{}\n{}\n{}".format(METHOD,conformers, top, charge))

def getCoords(infile, i):
	coords = []
	ATOMS = {
		"H"  : "1",  "He" : "2",  "Li" : "3",  "Be" : "4",  "B"  : "5",  "C"  : "6", 
		"N"  : "7",  "O"  : "8",  "F"  : "9",  "Ne" : "10", "Na" : "11", "Mg" : "12",
		"Al" : "13", "Si" : "14", "P"  : "15", "S"  : "16", "Cl" : "17", "Ar" : "18",
		"K"  : "19", "Ca" : "20", "Sc" : "21", "Ti" : "22", "V"  : "23", "Cr" : "24",
		"Mn" : "25", "Fe" : "26", "Co" : "27", "Ni" : "28", "Cu" : "29", "Zn" : "30",
		"Ga" : "31", "Ge" : "32", "As" : "33", "Se" : "34", "Br" : "35", "Kr" : "36",
		"Rb" : "37", "Sr" : "38", "Y"  : "39", "Zr" : "40", "Nb" : "41", "Mo" : "42",
		"Tc" : "43", "Ru" : "44", "Rh" : "45", "Pd" : "46", "Ag" : "47", "Cd" : "48",
		"In" : "49", "Sn" : "50", "Sb" : "51", "Te" : "52", "I"  : "53", "Xe" : "54",
		"Cs" : "55", "Ba" : "56", "La" : "57", "Ce" : "58", "Pr" : "59", "Nd" : "60",
		"Pm" : "61", "Sm" : "62", "Eu" : "63", "Gd" : "64", "Tb" : "65", "Dy" : "66",
		"Ho" : "67", "Er" : "68", "Tm" : "69", "Yb" : "70", "Lu" : "71", "Hf" : "72",
		"Ta" : "73", "W"  : "74", "Re" : "75", "Os" : "76", "Ir" : "77", "Pt" : "78",
		"Au" : "79", "Hg" : "80", "Tl" : "81", "Pb" : "82", "Bi" : "83", "Po" : "84",
		"At" : "85", "Rn" : "86", "Fr" : "87", "Ra" : "88", "Ac" : "89", "Th" : "90",
		"Pa" : "91", "U"  : "92", "Np" : "93", "Pu" : "94"
	}
	for i in range(i,len(infile)):
		line = infile[i]
		if '@<TRIPOS>BOND' in line:
			return coords
		else:
			l = line.split()
			atom = l[1]
			try: atom_num = ATOMS[atom][:1]
			except: atom_num = ATOMS[atom][0]
			x = l[2]
			y = l[3]
			z = l[4]
			coords.append([ atom_num, atom, x, y, z ])

def writeGamessInput(ec_input_file, infile):
	for i in range(len(infile)):
		line = infile[i]
		if '@<TRIPOS>ATOM' in line:
			coords = getCoords(infile ,i+1)
			break
	with open(ec_input_file,'w') as outfile:
		outfile.write('''! Run GAMESS Minimization 
 $BASIS GBASIS=MINI $END
 $CONTRL SCFTYP=RHF RUNTYP=OPTIMIZE MAXIT=200 ICHARG={} MULT=1 $END
 $STATPT OPTTOL=0.0005 NSTEP=1000 $END

 $DATA 
Title
C1
'''.format(charge))
		for i in coords:
			outfile.write("{:<6}{:>5}{:>12}{:>12}{:>12}\n".format(i[1],float(i[0]),i[2],i[3],i[4]))
		outfile.write(" $END\n")

def writeSQMInput(ec_input_file, infile):
	for i in range(len(infile)):
		line = infile[i]
		if '@<TRIPOS>ATOM' in line:
			coords = getCoords(infile ,i+1)
			break
	with open(ec_input_file,'w') as outfile:
		outfile.write('''Run semi-empirical minimization
 &qmmm
  qm_theory='{}',   qmcharge={},
 /
'''.format(qm_theory, charge))
		for i in coords:
			outfile.write("{:>4}{:>6}{:>14}{:>14}{:>14}\n".format(i[0],i[1],i[2],i[3],i[4]))

def writeMol2File(outfile, new_coords, new_charges, heat_of_formation):
	with open(outfile,'r') as f:
		f = f.readlines()
	with open(outfile, 'w') as out:
		for i in f:
			if i.strip() == '*****':
				out.write(str(heat_of_formation)+'\n')
			elif len(i.split()) == 9:
				i = i.split()
				charge = new_charges[0]
				x = new_coords[0][0]
				y = new_coords[0][1]
				z = new_coords[0][2]
				out.write('{:>7} {:<5}{:>10}{:>10}{:>10} {:<6} {:<4}{:<8}{:>10}\n'.format(i[0],i[1],x,y,z,i[5],i[6],i[7],charge))
				del new_coords[0]
				del new_charges[0]
			else:
				out.write(i)

def gamessCleanup(key):
    scratch_dir='/tmp/'
    for i in os.listdir(scratch_dir):
        if key in i:
            os.remove(os.path.join(scratch_dir, i))

def getSqmCoords(f,i):
	new_coords = []
	for i in range(i+4,len(f)):
		line = f[i]
		if line == '\n':
			return new_coords
		else:
			line = line.split()
			x = line[4]
			y = line[5]
			z = line[6]
			new_coords.append([x,y,z])

def getSqmCharges(f,i):
	new_charges = []
	for i in range(i+2,len(f)):
		line = f[i]
		if 'Total Mulliken Charge' in line:
			return new_charges
		else:
			line = line.split()
			new_charges.append(line[-1])

def catchGamessErrors(fn):
    with open(fn,'r') as f:
        file = f.read()
    if ' ddikick.x: exited gracefully.' not in file:
        print('ERROR: GAMESS ERROR DETECTED. \nPLEASE REVIEW THE LOG FILE: {}\n\n'.format(fn))
        sys.exit()

def runGamess(ec_input_file, ec_output_file, outfile):
	ec_files = ec_input_file.replace('.inp','')
	try:
		with open(ec_output_file,'w') as F:
			call(['rungms', ec_input_file], stdout=F)
			catchGamessErrors(ec_output_file)
			call(['cp',"/tmp/{}.*".format(ec_files),'.'])
			gamessCleanup(ec_files)
	except KeyboardInterrupt:
		print('\nExiting per User Request\n')
		sys.exit()
	except:
		print("Couldn't locate the GAMESS package for computing energies.\nPlease either use the flag -sqm followed by it's path, or add sqm to your path")
		sys.exit()
	with open(ec_output_file) as f:
		f = f.readlines()
	# for i in range(len(f)):
	# 	line = f[i]
	# 	if 'Heat of formation' in line:
	# 		line = line.split()
	# 		heat_of_formation = line[4]
	# 	elif 'Atomic Charges' in line:
	# 		new_charges = getSqmCharges(f, i)
	# 	elif 'Final Structure' in line:
	# 		new_coords = getSqmCoords(f, i)
	# writeMol2File(outfile, new_coords, new_charges, heat_of_formation)
	# return heat_of_formation

def runSqm(ec_input_file, ec_output_file, outfile):
	try:
		call([SQM, '-O', 
			'-i', ec_input_file,
			'-o', ec_output_file
			 ])
	except KeyboardInterrupt:
		print('\nExiting per User Request\n')
		sys.exit()
	except:
		print("Couldn't locate the sqm package for computing energies.\nPlease either use the flag -sqm followed by it's path, or add sqm to your path")
		sys.exit()
	with open(ec_output_file) as f:
		f = f.readlines()
	for i in range(len(f)):
		line = f[i]
		if 'Heat of formation' in line:
			line = line.split()
			heat_of_formation = line[4]
		elif 'Atomic Charges' in line:
			new_charges = getSqmCharges(f, i)
		elif 'Final Structure' in line:
			new_coords = getSqmCoords(f, i)
	writeMol2File(outfile, new_coords, new_charges, heat_of_formation)
	return heat_of_formation

def getInputFiles():
	file_list = []
	for i in os.listdir():
		if i.endswith('.mol2'):
			file_list.append(i)
	if len(file_list) < 1:
		print("ERROR: Couldn't locate any mol2 files!\nMake sure there are mol2 files in this directory and restart\n")
		sys.exit()
	else:
		return file_list

def writeConformerFile(output_template, conf_file, conformers):
	outfile = output_template.format(conformers)
	with open(outfile, 'w') as f:
		for i in conf_file:
			f.write(i)
	return outfile

def writeAnalysisScript():
	with open('analyzeOutput.py','w') as f:
		f.write('''
import sys, os
from getpass import getuser
from subprocess import check_output as co
from subprocess import call

workdir = os.getcwd()
user = getuser()


def writeMol2File(outfile, final_coords, final_charges, min_energy):
	with open(outfile,'r') as f:
		f = f.readlines()
	print(outfile)
	with open(outfile, 'w') as out:
		try:
			for i in f:
				if i.strip() == '*****':
					out.write(str(min_energy)+'\\n')
				elif len(i.split()) == 9:
					i = i.split()
					charge = final_charges[0]
					x = final_coords[0][0]
					y = final_coords[0][1]
					z = final_coords[0][2]
					line = ('{:>7} {:<6}{:>10}{:>10}{:>10} {:<6} {:<4}{:<8}{:>10}\\n'.format(i[0],i[1],x,y,z,i[5],i[6],i[7],charge))
					print(line)
					out.write(line)
					del final_coords[0]
					del final_charges[0]
				else:
					out.write(i)
		except:
			print("Problem with file: {}\\n".format(outfile))
			with open('zLogfile','a+') as log:
				log.write("Problem with file: {}\\n".format(outfile))

def getSqmCoords(f,i):
	sqm_coords = []
	for i in range(i+4,len(f)):
		line = f[i]
		if line == '\\n':
			return sqm_coords
		else:
			line = line.split()
			x = line[4]
			y = line[5]
			z = line[6]
			sqm_coords.append([x,y,z])

def getSqmCharges(f,i):
	sqm_charges = []
	for i in range(i+2,len(f)):
		line = f[i]
		if 'Total Mulliken Charge' in line:
			return sqm_charges
		else:
			line = line.split()
			sqm_charges.append(line[-1])

def getGamessCoords(f,i):
	gamess_coords = []
	for i in range(i+4,len(f)):
		line = f[i]
		if line == '\\n':
			return gamess_coords
		else:	
			line = line.split()
			x = line[2][:8] if float(line[2]) < 0 else line[2][:7]
			y = line[3][:8] if float(line[3]) < 0 else line[3][:7]
			z = line[4][:8] if float(line[4]) < 0 else line[4][:7]
			gamess_coords.append([x,y,z])

def getGamessCharges(f,i):
	gamess_charges = []
	for i in range(i+2,len(f)):
		line = f[i]
		if line == '\\n':
			return gamess_charges
		else:
			line = line.split()
			gamess_charges.append(line[-1])


energy_dct = {}
output_file_list = []
with open('analysis.in') as f:
	f = f.readlines()
method = f[0].strip().lower()
conformers = int(f[1].strip())
top = int(f[2].strip())
charge = int(f[3].strip())
if method == 'sqm':
	for i in os.listdir():
		if i.endswith('.out') and '_conf' in i:
			output_file_list.append(i)
	for output_file in output_file_list:
		outfile = output_file.replace('.out','.mol2')
		with open(output_file) as f:
			f = f.readlines()
		for i in range(len(f)):
			line = f[i]
			if 'Heat of formation' in line:
				line = line.split()
				min_energy = line[4]
			elif 'Atomic Charges' in line:
				final_charges = getSqmCharges(f, i)
			elif 'Final Structure' in line:
				final_coords = getSqmCoords(f, i)
		writeMol2File(outfile, final_coords, final_charges, min_energy)
		energy_dct[float(min_energy)] = outfile
elif method == 'gamess':
	print('Running GAMESS Analysis')
	for i in os.listdir():
		if i.endswith('.log') and '_conf' in i:
			output_file_list.append(i)
	for output_file in output_file_list:
		outfile = output_file.replace('.log','.mol2')
		print(output_file)
		try:
			with open(output_file) as f:
				f = f.readlines()
			for i in range(len(f)):
				line = f[i]
				if 'TOTAL ENERGY =' in line:		#FIND ENERGY
					line = line.split()
					min_energy = line[3]
				elif 'TOTAL MULLIKEN AND LOWDIN ATOMIC POPULATIONS' in line:
					final_charges = getGamessCharges(f, i)
				elif '***** EQUILIBRIUM GEOMETRY LOCATED *****' in line:
					final_coords = getGamessCoords(f, i)

			# print('ENERGY = {}'.format(min_energy))
			if final_coords and final_charges:
				writeMol2File(outfile, final_coords, final_charges, min_energy)
				energy_dct[float(min_energy)] = outfile
		except:
			print('Error with {}'.format(output_file))
else:
	print('Invalid method listed in analysis.in. Check the method used.')
	sys.exit()
# print(energy_dct)

if conformers < top:
	top = conformers
while len(energy_dct) > top:
	maxval = max([i for i in energy_dct])
	del energy_dct[maxval]
try:
	os.mkdir('best_conformers')
except:
	print('best_conformers already exists')
for i in energy_dct:
	filename = energy_dct[i]
	os.rename("{}/{}".format(workdir, filename), "{}/best_conformers/{}".format(workdir, filename))
os.chdir('best_conformers')
with open('ALL_CONFORMERS.mol2','w') as F:
	for i in os.listdir():
		with open(i) as f:
			f = f.read()
			F.write(f)
''')

def separateAndAnalyze(output_file, MAKE_INPUT_FILES, RUN, METHOD, molecule):
	global user
	joblist = []
	energy_dct = {}
	output_template = output_file.replace('_conformers', '_conf_{}')
	with open(output_file,'a+') as f:
		f.write('ENDLINE')
	conformers = 0
	conf_file = []
	with open(output_file) as f:
		f = f.readlines()
	for i in f:
		if '@<TRIPOS>MOLECULE' in i and conformers == 0:
			conf_file.append(i)
			conformers += 1
		elif '@<TRIPOS>MOLECULE' in i or 'ENDLINE' in i:
			outfile = writeConformerFile(output_template, conf_file, conformers)
			if MAKE_INPUT_FILES:
				if METHOD == 'sqm':
					ec_input_file = outfile.replace('.mol2','.in')
					ec_output_file = outfile.replace('.mol2','.out')
					batchfile = outfile.replace('.mol2','.sh')
					writeSQMInput(ec_input_file, conf_file)
					with open(batchfile,'w') as ec_file:
						ec_file.write('''#!/bin/bash

#SBATCH --time=00-01:00         # time (DD-HH:MM)
#SBATCH --nodes=1 --ntasks-per-node=8
#SBATCH --mem-per-cpu=15M   # memory per CPU core
#SBATCH --mail-user={}@byu.edu   # email address
#SBATCH --mail-type=FAIL
#SBATCH --requeue

# Set the max number of threads to use for programs using OpenMP. Should be <= ppn. Does nothing if the program doesn't use OpenMP.
export OMP_NUM_THREADS=$SLURM_CPUS_ON_NODE

# LOAD MODULES, INSERT CODE, AND RUN YOUR PROGRAMS HERE

type module &>/dev/null
[[ $? -eq 0 ]] || . /etc/profile  # source /etc/profile if `module` isn't defined

module purge
module load gcc openmpi python amber/18

echo "Started `date`"
sqm -O -i {} -o {}
echo "Ended `date`"
'''.format(user, ec_input_file, ec_output_file))
					# with open('molecule{}_submit_all.sh'.format(molecule),'a+') as b:
					# 	b.write('bash {}\n'.format(batchfile))
					joblist.append(ec_output_file)
				elif METHOD == 'gamess':
					ec_input_file = outfile.replace('.mol2','.inp')
					ec_output_file = outfile.replace('.mol2','.log')
					batchfile = outfile.replace('.mol2','.sh')
					writeGamessInput(ec_input_file, conf_file)
					with open(batchfile,'w') as ec_file:
						ec_file.write('''#!/bin/bash

#SBATCH --time=00-01:00         # time (DD-HH:MM)
#SBATCH --nodes=1 --ntasks-per-node=16
#SBATCH --mem-per-cpu=500M   # memory per CPU core
#SBATCH --mail-user={}@byu.edu   # email address
#SBATCH --mail-type=FAIL
#SBATCH --requeue

# LOAD MODULES, INSERT CODE, AND RUN YOUR PROGRAMS HERE

type module &>/dev/null
[[ $? -eq 0 ]] || . /etc/profile  # source /etc/profile if `module` isn't defined

module purge
module load intel-compilers
module load intel-mpi
module load gamess #most likely doesn't work

export PATH=$PATH:/apps/gamess/2018-09-30/intel-2018_sockets


echo "Started `date`"
MWORDS=200 rungms {} 00 16 16 | tee {}
echo "Ended `date`"
'''.format(user, ec_input_file, ec_output_file))
					# with open('molecule{}_submit_all.sh'.format(molecule),'a+') as b:
					# 	b.write('bash {}\n'.format(batchfile))
					joblist.append(ec_output_file)
			else:
				if METHOD == 'sqm':
					ec_output_file = outfile.replace('.mol2','.out')
					ec_input_file =  outfile.replace('.mol2','.in')
					writeSQMInput(ec_input_file, conf_file)
					print('Running sqm for: {}'.format(outfile))
					start_time = time()
					heat_of_formation = runSqm(ec_input_file, ec_output_file, outfile)
					energy_dct[heat_of_formation] = outfile
					print('Done -- Finished in {} seconds'.format(ceil(time() - start_time)))
				elif METHOD == 'gamess':
					ec_output_file = outfile.replace('.mol2','.log')
					ec_input_file = outfile.replace('.mol2','.inp')
					writeGamessInput(ec_input_file, conf_file)
					print('Running gamess for: {}'.format(outfile))
					start_time = time()
					heat_of_formation = runGamess(ec_input_file, ec_output_file, outfile)
					energy_dct[heat_of_formation] = outfile
					print('Done -- Finished in {} seconds'.format(ceil(time() - start_time)))
			if 'ENDLINE' not in i:
				conformers += 1
				conf_file = [i]
		else:
			conf_file.append(i)
	conf_list = os.listdir()
	num_conformers = 0
	for i in conf_list:
		if i.endswith('.mol2') and "_conf_" in i:
			num_conformers += 1
	print(f"\nGenerated {num_conformers} conformers\n")
	with open('molecule{}_submit_all.sh'.format(molecule),'w') as f:
		f.write(f'''#!/bin/bash

#SBATCH --time=00-01:00         # time (DD-HH:MM)
#SBATCH --nodes=1 --ntasks-per-node={8 if METHOD == 'sqm' else 16}
#SBATCH --mem-per-cpu={15 if METHOD == 'sqm' else 500}M   # memory per CPU core
#SBATCH --mail-user={user}@byu.edu   # email address
#SBATCH --mail-type=FAIL
#SBATCH --requeue
#SBATCH --array=1-{num_conformers + 1}

if [[ "$SLURM_ARRAY_TASK_ID" -eq "{num_conformers + 1}" ]]; then

	python analyzeOutput.py

else
	
	bash {output_template.replace(".mol2",".sh").format("$SLURM_ARRAY_TASK_ID")}


''')
	with open('molecule{}_submit_all.sh'.format(molecule),'a+') as b:
		b.write('\nfi \n')
	if RUN:
		#call(['bash','molecule{}_submit_all.sh'.format(molecule)])
		output_fn = output_file.replace('.mol2','')
		# with open(output_fn,'w') as f:
		# 	for i in joblist:
		# 		f.write(i+'\n')
		writeAnalysisInput(METHOD, charge, output_fn, conformers, top)
		writeAnalysisScript()
	return energy_dct, conformers

def main(input_file, output_file, logfile, nconf, score, top, MAKE_INPUT_FILES, RUN, METHOD, molecule):
	global INPUT_ONLY
	if not INPUT_ONLY:
		with open(logfile,'w') as outfile:
			call(['obabel', input_file,
				  '-O', output_file, 
				  '--conformer', 
				  '--nconf', nconf,
				  '--score', score,
				  '--writeconformers'
				  ])
	energy_dct, conformers = separateAndAnalyze(output_file, MAKE_INPUT_FILES, RUN, METHOD, molecule)
	if not MAKE_INPUT_FILES:
		if conformers < top:
			top = conformers
		while len(energy_dct) > top:
			maxval = max([i for i in energy_dct])
			del dct[maxval]
		os.mkdir('best_conformers')
		# os.mkdir('other_files')
		for i in energy_dct:
			filename = energy_dct[i]
			os.rename("{}/{}".format(workdir, filename), "{}/best_conformers/{}".format(workdir, filename))


if __name__ == '__main__':
	##############################################
	#			  DEFAULT VARIABLES				 #
	##############################################
	ARGS = sys.argv
	nconf = '5000'
	top = 50
	charge = '0'
	score = 'rmsd'
	input_file = None
	output_file = None
	SQM = 'sqm'
	qm_theory = 'AM1'
	MAKE_INPUT_FILES = True
	INPUT_ONLY = False
	RUN = False
	molecule = 0
	METHOD = 'gamess'
	##############################################
	if len(ARGS) < 2:
		print('\nRunning with the Defalt Values\n')
	else:
		for i in range(1,len(ARGS)):
			if ARGS[i] in ['-h','--help']:
				usage()
				sys.exit()
			elif ARGS[i] in ['--remove_conf']:
				removeConformers()
				sys.exit()
			elif ARGS[i] in ['-io','--inp_only']:
				MAKE_INPUT_FILES = True
				INPUT_ONLY = True
			elif ARGS[i] in ['-R','--RUN']:
				RUN = True
				MAKE_INPUT_FILES = True
			elif ARGS[i] in ['-i','--input']:
				input_file = ARGS[i+1]
				input_filename, extention  = input_file.split('.')
			elif ARGS[i] in ['-n','--nconf']:
				nconf = ARGS[i+1]
			elif ARGS[i] in ['-s','--score']:
				score = ARGS[i+1]
				if score not in ['rmsd', 'energy', 'minrmsd', 'minenergy']:
					print("ERROR: {} is not an acceptable scoring method\nTry genconf --help for avalible methods\n".format(score))
			elif ARGS[i] in ['-t','--top']:
				top = int(ARGS[i+1])
			elif ARGS[i] in ['-o','--output']:
				output_file = ARGS[i+1]
			# elif ARGS[i] in ['-sq','--sqm']:			# This provides the user with the option to pass an alternate path to the sqm executable,
			# 	SQM = ARGS[i+1] 						# however this is NOT currently being used
			elif ARGS[i] in ['-c','--charge']:
				charge = ARGS[i+1]
			elif ARGS[i] in ['-m','--method']:
				METHOD = ARGS[i+1].lower()
				if METHOD not in ['sqm', 'gamess', 'gaussian']:
					print("ERROR: {} is not an acceptable method for calculating energy\nTry genconf --help for avalible methods\n".format(score))
			elif ARGS[i] in ['-qm','--qm_theory']:
				qm_theory = ARGS[i+1]
				if qm_theory not in ['AM1', 'RM1', 'MNDO', 'PM3-PDDG', 'MNDO-PDDG', 'PM3-CARB1,' 'MNDO/d', 'AM1/d', 'PM6', 'DFTB2', 'DFTB3', 'AM1-D*', 'PM6-D', 'AM1-DH+', 'PM6-DH+']:
					print("ERROR: {} is not an acceptable qm_theory\nTry genconf --help for avalible theories\n".format(qm_theory))
	if not input_file:
		file_list = getInputFiles()
		for input_file in file_list:
			molecule += 1
			input_filename, extention  = input_file.split('.')
			output_file = input_filename + "_conformers.mol2"
			logfile = input_filename + "_logfile"
			main(input_file, output_file, logfile, nconf, score,top, MAKE_INPUT_FILES, RUN, METHOD, molecule)
		print('Finished Running {} Total Molecules'.format(molecule))
	else:
		logfile = input_filename + "_logfile"
		main(input_file, output_file, logfile, nconf, score, top, MAKE_INPUT_FILES, RUN, METHOD, molecule)

	sub = submit()
	if sub == 'submit':
		new_dir = syncDir()
		runJob(new_dir, 'molecule*.sh')
	elif sub == 'sync':
		new_dir = syncDir()
		print(f'Files sent to {new_dir}')
	print('Done')
